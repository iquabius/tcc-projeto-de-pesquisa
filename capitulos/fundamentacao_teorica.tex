\section{Fundamentação Teórica}
\label{sec:fund-teor}

\subsection{Interfaces Gráficas do Usuário (GUIs)}
\label{sec:guis}

\subsubsection{GUIs em Aplicações Desktop}
\label{sec:guis-desktop}

% - utilizam toolkits

\subsubsection{GUIs em Aplicações Web}
\label{sec:guis-web}

%\subsubsubsection{JavaScript}
%\label{sec:javascript}
%
%\subsubsubsection{DOM \emph{(Document Object Model)}}
%\label{sec:dom}
%
%% \subsubsection{Programação com \emph{Callbacks}}

\subsection{Programação Funcional}
\label{sec:prog-funcional}

% "Functional Programming (enabled by lambdas with closure)"
% Contextualização Histórica
% Renascença da Programação Funcional


\subsubsection{Funções Puras \emph{(Pure Functions)}}
\label{sec:func-puras}

% transparência referêncial

\subsubsubsection{Efeitos Colaterais \emph{(Side-effects)}}

\subsubsection{Funções de Primeira Classe \emph{(First Class Functions)}}

% - Expressões lambda / funções anônimas / Closures

\begin{listing}[H]
  \centering
  \caption{Atribuição de funções a variáveis}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    var sumar = function(x, y) {
      return x + y
    }

    // Utilizando 'let' e 'Arrow Functions' do JavaScript ES6
    let subtrair = (x, y) => {
      return x - y
    }

    // Quando a função possui apenas uma expressão
    // as chaves podem ser removidas
    let multiplicar = (x, y) => return x * y

    // Quando a única expressão é um retorno, a palavra chave
    // 'return' também pode ser removida
    let dividir = (x, y) => x / y
  \end{minted}
  \label{code:app-init}
\end{listing}

\begin{listing}[H]
  \centering
  \caption{Expressões \emph{lambda}}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    // A função 'f' chama a função 'g' passando o valor do parâmetro 'x'
    // como argumento.
    let f = (g, x) => g(x)

    // Dois valores são passados a função 'f':
    // O primeiro é uma função 'lambda' que retorna 'y + 1'
    // O segundo é o numero '99'
    let resultado = f((y) => y + 1, 99)
    // Ao executar a função 'f', a expressão lambda é vinculada
    // a variável 'g', definida na lista de argumentos.
  \end{minted}
  \label{code:app-init}
\end{listing}

\subsubsection{Funções de Ordem Superior \emph{(Higher-order Functions)}}

\emph{Funções de Ordem Superior} são funções que aceitam outras funções como
argumento, ou retornam uma função.

\subsubsubsection{Funções como argumentos}

\subsubsubsection{Funções como valores retornados}

\subsubsection{Primitivas Básicas da PF}
\label{sec:primitivas-pf}

% \emph{map}, \emph{filter}, \emph{fold}, \emph{reduce}, \emph{scan}, \emph{zip}.

As primitivas \emph{map} e \emph{filter} são funções de ordem superior.

\begin{listing}[H]
  \centering
  \caption{Primitiva \emph{map}}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    // Computa uma lista com os quadrados dos valores de 'numbers'
    let squaredNumbers = numbers.map(num => Math.pow(num, 2))

    //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
  \end{minted}
  \label{code:app-init}
\end{listing}

\begin{listing}[H]
  \centering
  \caption{Primitiva \emph{filter}}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    // Função que diz se um número é ou não par
    let isEven = (n) => n % 2 == 0

    // Filtra os números pares
    let evenNumbers = numbers.filter(isEven)

    //-> [0, 2, 4, 6, 8]
  \end{minted}
  \label{code:app-init}
\end{listing}

\subsubsection{Composição de Funções}

%\subsubsection{\emph{Currying}}
%

\subsection{O Imperativo e o Declarativo na Programação}

A função \emph{doubleNumbers} no Fragmento de Código
\ref{code:dobrar-nums-imperativo} recebe uma lista de números e produz numa nova
lista onde todos os números são multiplicados por 2. Essa implementação utiliza
o estilo \emph{imperativo} de programação.

\begin{listing}[H]
  \centering
  \caption{Dobrando números de uma lista de forma imperativa}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    function doubleNumbers(numbers) {
      const doubled = []
      const l = numbers.length

      for (let i = 0; i < l; i++) {
        doubled.push(numbers[i] * 2)
      }

      return doubled
    }
  \end{minted}
  \label{code:dobrar-nums-imperativo}
\end{listing}

\begin{listing}[H]
  \centering
  \caption{Dobrando números de uma lista de forma declarativa}
  \begin{minted}
    [
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    fontsize=\scriptsize, % scriptsize, footnotesize, small
    linenos,
    mathescape
    ]
    {js}
    function doubleNumbers(numbers) {
      return numbers.map(n => n * 2)
    }

    doubleNumbers([1, 2, 3])
    // [2, 4, 6]
  \end{minted}
  \label{code:dobrar-nums-declarativo}
\end{listing}

\subsection{Programação Orientada a Objetos e o \emph{Observer Pattern}}


\subsection{Programação Funcional Reativa (PFR)}
\label{sec:pfr}

% "FRP permits the modeling of systems that must respond to input over time in a
% simple and declarative manner." ~ Amsden (2011), Survey on FRP

% "A program in an FRP language generally corresponds quite closely to a
% mathematical model of the system being implemented." ~ Amsden (2011), Survey
% on FRP
%   - Programação Reativa
%     - “[…] is programming with asynchronous data streams” – André Staltz
%   - merge, replay, retry, skip, start, startWith


\subsubsection{As 10 Primitivas Básicas da PFR}
\label{sec:pfr-10-primitivas}

\emph{map}, \emph{merge}, \emph{hold}, \emph{snapshot}, \emph{filter},
\emph{lift}, \emph{never}, \emph{constant}, \emph{sample}, \emph{switch}.

\subsubsection{Combinação de Primitivas}
\label{sec:pfr-combinacao}

\subsubsection{Arcabouços \emph{(Frameworks)} PFR}
\label{sec:pfr-frameworks}

Rx.JS, Bacon.js
% Ferramentas
%   Bibliotecas & Frameworks
%   Bacon.js
%   Cycle.js → Model-View-Intent
%   Elm → Model-Update-View
%   Rx
%   Meteor

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../projeto"
%%% End:
