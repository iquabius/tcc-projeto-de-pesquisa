\section{Justificativa}\label{ljustificativa}

% - websockets, push notifications, AppCache, service workers, web workers
%   - http://bit.ly/serviceworkers_webworkers_websockets
Interatividade em páginas web se deu com a
introdução do \emph{JavaScript} nos navegadores,
e desde o advento do \emph{Ajax}\footnote{
  \emph{Ajax (Asynchronous JavaScript + XML)} é uma
  abordagem que abrange um conjunto de técnicas e
  tecnologias que permitem a criação de páginas web
  dinâmicas onde a troca de conteúdo entre cliente e
  servidor ocorre de forma assíncrona, sem a necessidade
  de recarregar a página toda a cada interação do
  usuário \cite{garrett2005ajax}.
},
elas têm se tornado cada vez mais interativas,
dando origem a uma nova gama de aplicações web com interfaces
ricas\footnote{
  Alguns exemplos de aplicações ricas são:
  calendários (\emph{Google Calendar}),
  clientes de email (\emph{Gmail} e \emph{Outlook}),
  \emph{chats} (\emph{Facebook Messenger}),
  editores de texto (\emph{Google Docs}),
  mapas (\emph{Google Maps}, \emph{Waze}) e
  planilhas (\emph{Google Sheets}).
  Leia mais no TCC de \citeonline{kuntze2008aplicacoesricas}:
  \emph{Aplicações Ricas com Ajax}.
} e responsivas que oferecem ao usuário uma experiência
similar as aplicações \emph{mobile} ou \emph{desktop}.
Assim como em qualquer interface gráfica, interfaces web
precisam reagir a vários eventos imprevisíveis do ambiente
externo, provindos tanto dos usuários (e.g. \emph{clicks}
do \emph{mouse}, pressionamento de teclas, gestos multitoque,
etc.) quanto de outros sistemas (e.g. mensagens do servidor,
sinais de sensores, etc.).
Devido a esses aspectos, interfaces gráficas são caracterizadas
como \emph{reativas}.

%  in a timely fashion = em tempo hábil
Atualmente o paradigma de \emph{Programação Orientada a Eventos
(EDP)} é o mais empregado na
coordenação de eventos em sistemas interativos.
Esse modelo consiste de um \emph{laço de eventos (event loop)}
que repetidamente espera por eventos, e quando ocorre um
evento, uma \emph{função de chamada de retorno (callback)}
apropriada é disparada para tratá-lo.
Essa abordagem configura uma das formas mais complexas de se
programar aplicações interativas \cite{
  edwards2009coherent,
  fischer2007tasks,
  maier2010deprecating,
  reppy1992higher},
devido ao fato de que aplicações desenvolvidas utilizando
esse mecanismo apresentam um fluxo de controle desestruturado
% implícito (Flapjax)
e imprevisível, além de depender crucialmente de
\emph{efeitos colaterais\footnotemark} para
\footnotetext{
  Do inglês \emph{side-effects:} característica muito comum
  em linguagens imperativas, onde uma função ou expressão pode
  modificar algum estado externo (e.g. alterar uma variável
  global, produzir uma saída na tela/terminal, escrever no
  sistema de arquivos, etc.). Em programação funcional o uso de
  efeitos colaterais é desencorajado, e deve ser usado apenas
  quando absolutamente necessário -- e.g. manipular uma variável
  global não é absolutamente necessário, mas imprimir uma mensagem
  na tela pode ser.
}
gerenciar seu estado \cite{
  meyerovich2009flapjax,
  muller2015interactive,
  muller2015practical}.
Na literatura, a forma desconcertante com que \emph{callbacks}
coordenam alterações no estado instiga uma descrição infame:
\emph{Callback Hell} \cite[p.~2]{edwards2009coherent}.
% bainomugisha2013survey, muller2015practical
% inversão de controle

Vale ressaltar que a preocupação desnecessária com o
fluxo de controle e o mau gerenciamento de estado são
consideradas as principais causas de complexidade em
sistemas contemporâneos, pois afetam o entendimento das
várias partes do código por parte do programador,
além de dificultar manutenção e testes de software
\cite{moseley06out}.
Uma análise das aplicações \emph{desktop} da Adobe,
relatada em 2006, indicou que o código que coordena a
lógica de manuseio de eventos, \emph{widgets}, e outros
componentes da interface gráfica, representa cerca de
um terço de todo o código, e mais da metade dos \emph{bugs}
reportados \cite{jarvi2008property}.
Sendo o alto grau de interatividade parte inerente da
interface gráfica de uma aplicação e, por consequência,
altamente orientada a eventos, seu desenvolvimento e
manutenção se tornam um desafio.

%   - observer pattern

% declarative vs imperative
%   - specification (what) vs. execution (how)
%     - Declarative Interaction Design for Data Visualization
%   - modeling vs presentation
%     - Elm
%     - FR Animation
%
% FRP
%  - Outros tipos de software podem ser considerados reativos, como um sistema
%    embarcado que reage a sinais de sensores, ou um sistema distribuído que
%    precisa reagir a mensagens na rede.

\emph{Programação Funcional Reativa (FRP)} é uma
alternativa promissora que recentemente tem sido
explorada e aplicada na programação de sistemas
orientados a eventos, como interfaces gráficas,
e em uma variedade de outros domínios
de característica reativa, tal como robótica,
síntese de música, animações e \emph{video games}.
Conceitos de \emph{FRP} podêm ser adotados para
se coordenar eventos em aplicações interativas de forma declarativa
% programar aplicações interativas de forma declarativa
em um nível mais elevado de abstração, resultando em
código fonte que expressa melhor a solução implementada.

% it replaces listeners (also known as callbacks) in the widely-used
% observer pattern, making your code cleaner, clearer, more robust
% and more maintainable – in a word – simpler. (FRP, 2016)

% FRP is a specific programming technique to improve your code in
% an area that just happens to be a common source of complexity (and
% therefore bugs): event propagation. (FRP, 2016)

% This yields the advantage that programmers need not to worry about
% the order of events and computation dependencies. Hence, reactive
% programming languages abstract over time management, just as garbage
% collectors abstract over memory management. (A Survery on RP)


Este trabalho pretende contextualizar a situação atual
de como interfaces orientadas a eventos são implementadas,
apresentar os conceitos das abordagens alternativas, e
fornecer implementações de alguns componentes comuns em
interfaces gráficas, com a finalidade de testar e comparar
tais abordagens através do uso de algumas ferramentas
(linguagens e/ou \emph{frameworks}). Atenção especial será
dada ao ambiente \emph{web}, ou seja, interfaces de
aplicações utilizadas nos navegadores, e dependendo do
levantamento feito, alguns exemplos poderão ser dados
com alguma ferramenta \emph{FRP} para o ambiente
\emph{mobile} e/ou \emph{desktop}.
