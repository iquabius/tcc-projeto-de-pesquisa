# -*- ispell-local-dictionary: "portugues"; -*-
* Fundamentação Teórica

** COMMENT Teoria da Computação

   O fenômeno da computação na qual a Ciência da Computação é fundada tem suas
   raízes na teoria da computabilidade que estuda os formalismos na qual pode-se
   expressar algorítimos e seus limites (Gabbrielli, 2010).

   #+ATTR_LATEX: :options [font={\normalfont\itshape},style=nextline]
   - Máquina de Turing :: É um modelo matemático de computação que define uma
        máquina, abstrata, que manipula simbolos em uma tira de fita de acordo
        com uma tabela de regras;
   - Cálculo Lambda :: “Sistema formal que estuda funções recursivas
                       computáveis, no que se refere a teoria da
                       computabilidade”;
   - Tese de Church-Turing :: “Hipótese sobre a natureza de dispositivos
        mecânicos de cálculo, como computadores, e sobre que tipo de algoritmos
        eles podem computar”;
   - Máquina de Turing universal (MTU) :: Concepção de Turing, também conhecido
        como ‘computador com programa armazenado’ (que coloca a ‘tabela de ação’
        --- instruções para a máquina --- na mesma ‘memória’ que os dados de
        entrada) influenciou fortemente /John von Neumann/ na concepção do
        EDVAC, um dos primeiros computadores;
   - Arquitetura de von Neumman :: Primeira descrição publicada --- no artigo
        /First Draft of a Report on the EDVAC/ (Von Neumman, 1945) --- do
        desenho /(design)/ lógico de um ‘computador com programa armazenado’;

*** Notas                                                          :noexport:
    “category theory is the "foundation" for type theory. Here, I would like to
    say something stronger. Category theory is type theory. Conversely, type
    theory is category theory.” — [[https://cs.stackexchange.com/a/3256/47237][StackExchange: Uday Reddy]]

    TODO: Look up
    /Set Theory/ studies operations on mathematical sets. /Relational Algebra/
    de builds on it's concepts to define data abstractions for databases.


** COMMENT Linguagens de Programação
*** História
    Máquina de Turing.
    Arquitetura de von Neumman.
    Instruções de máquina.
    Linguagens de montagem /(Assembly)/.
    Programação imperativa.

    Cálculo Lambda e a Tese de Church-Turing.
    LISP e linguagens funcionais.
    Programação declarativa.


*** Programação Imperativa e a Máquina de Turing
    “[...] ideia de estado de um programa e a computação de um programa como
    sucessivas transformações de estados.” (Melo, 2003)

    Melo (2003) apresenta uma tipologia das linguagens de programação:

    #+ATTR_LATEX: :options [noitemsep,font={\normalfont\itshape}]
    - assertivas
      #+ATTR_LATEX: :options [noitemsep,font={\normalfont\itshape}]
      - imperativas :: C, Pascal, Fortran
      - orientadas a objetos :: C++, Smalltalk
    #+ATTR_LATEX: :options [noitemsep]
    - declarativas
      #+ATTR_LATEX: :options [noitemsep,font={\normalfont\itshape}]
      - funcionais :: LISP, ML, Miranda, Haskell
      - lógicas :: PROLOG, Godel
      - orientadas a satisfações de restrições :: Mozart/OZ, Alice


*** Programação Declarativa e o Cálculo Lambda

*** Semântica de uma Linguagem

*** Sintaxe de uma Linguagem
**** Construtos linguísticos

     “Considerando a computação de um programa como uma máquina de transformação,
     podemos distinguir dois *estados* primordiais do programa: o *estado
     inicial* — quando nenhuma transformação sobre os dados ainda foi realizada —
     e o *estado final*, após todas as transformações realizadas pelo programa.”
     (Melo, 2003, pg.84)

     “Para programas sequenciais, a computação de um programa é, na realidade,
     uma transformação sucessiva de estados.” (Melo, 2003, pg.84)

     Expressões são mecanismos para a transformação de dados, alguns dados de
     entrada são fornecidos e um resultado obtido a partir da computação deles
     (Melo, 2003, pg.84).

     Comandos atuam sobre o fluxo de controle e estados do programa (Melo, 2003,
     pg.84).

     Segundo Sebesta (2003), os critérios de avaliação da linguagem são:
     /legibilidade/, /capacidade de escrita (writability)/, /confiabilidade/, e
     /custo/.
**** Expressões
     formadas por operadores e operandos, uma expressão é qualquer código que dê
     um valor depois de sua redução (ou avaliação). “em linguagens imperativas a
     redução de uma expressão pode modificar o valor de qualquer variável através
     de \emph{efeitos colaterais}” (gabbrielli, 2010).

     “As expressões são os elementos de transformação de dados em um programa: a
     partir de valores, uma transformação é aplicada e um valor resultado é
     produzido.” (Melo, 2003, pg. 84).

     “\textelp{} quando uma expressão que contém uma aplicação de função [],
     algumas operações internas à função podem acarretar mudanças no estado do
     programa.” (Melo, 2003, pg. 89).

**** Comandos
     Ao contrário das expressões, comandos nem sempre dá um valor ao ser
     avaliado.

     #+ATTR_LATEX: :options [font={\normalfont\itshape},style=nextline]
     - Atribuição :: Valores, variáveis e armazenamento na memória.
     - Comandos de controle explícito :: Comandos que decidem o caminho de
          execução do programa, dentre os vários possíveis:
          1. comandos compostos (blocos /begin...end/, /.../, etc)
          2. comando /goto/;
          3. e outros, como /break/, /continue/, /return/, e exceções (comandos
             mais elaborados para controle de sequência).
     - Comandos Condicionais :: /if...else/, /switch...case/;
     - Comandos Iterativos :: Unbounded (/while/, /do...while/) and bounded
          iteration (/for/, /foreach/, /for...in/);
     - Programação Estruturada :: A rejeição do comando /GOTO/ (Dijkstra, 1968)
          e o surgimento do conceito de /‘paradigmas de programação’/;
     - Recursão :: Na busca por linguagens /turing-equivalentes/, a recursão
                   pode ser pensada como uma alternativa aos comandos de
                   iteração.


*** Notas                                                          :noexport:
    “Some languages are discovered and some languages are invented. Some
    languages feel like a force of nature, and others feel like they are bolted
    together in a garage.” [[https://www.youtube.com/watch?v=bmFKEewRRQg][Rob Martin - Teaching functional programming to noobs]]

    | Turing Machine    |   |   |   |   |
    |-------------------+---+---+---+---|
    | von Neumman Arch. |   |   |   |   |
    | Assembly Langs.   |   |   |   |   |
    | Lambda Calculus   |   |   |   |   |


** Paradigmas de Programação
   Melo (2003, pg. 10) fala sobre as diferentes formas de solucionar problemas.
   Os elementos a serem representados, e os mecanismos que as linguagens devem
   prover para permitir a representação e a manipulação naturais dos elementos
   básicos.

   #+BEGIN_EXPORT latex
   \begin{citacao}
     Linguagens de programação orientadas a objetos podem ser vistas como
     ferramentas para construir soluções de problemas orientadas \emph{por}
     objetos, linguagens imperativas podem ser vistas como ferramentas para
     construir soluções de problemas orientadas \emph{por} dados, e linguagens
     declarativas podem ser vistas como ferramentas para construir soluções de
     problemas orientadas \emph{por} relações entre declarações. (pg. 10)
   \end{citacao}
   #+END_EXPORT

*** Programação Estruturada

*** Programação Procedural

*** Programação Orientada a Objetos

*** Programação Orientada a Eventos
   - Design Patterns :: /Observer Pattern/
   - /Callbacks/ ::

*** Programação Funcional
    #+BEGIN_EXPORT latex
    \enquote{A base do $\lambda$-cálculo é o conceito de avaliação de funções
      matemáticas, sendo esse o fundamento essencial da \emph{programação
        funcional.}} (Melo, 2003, pg. 130).
    #+END_EXPORT

    “Esse processo se dá por meio de transformações sucessivas do programa, que
    devem convergir para o resultado desejado. Essas transformações recebem o
    nome de /reduções/.” (Melo, 2003, pg. 130).

    “A execução de um programa funcional consiste na aplicação exaustiva das
    regras de redução.” (Melo, 2003, pg. 133).

    #+ATTR_LATEX: :options [font={\normalfont\itshape},style=nextline]
    - Cálculo lambda não tipado :: Inspiração original, em particular do /Lisp/,
         umas das primeiras linguagens a ter suporte para programação funcional;
    - Programação declarativa ::
    - Expressões :: (1) Variáveis imutáveis (variáveis vinculadas a expressões,
                    que mantém um único valor durante todo o tempo de vida
                    útil). (2) Expressões puras e efeitos colaterais na redução
                    de expressões;
    - Funções :: (1) PF é baseada na aplicação de funções. (2) Faz amplo uso de
                 expressões /lambda/ (funções anônimas). (3) Também desencoraja
                 o uso de funções impuras (que contém efeitos colaterais);
    - Funções de primeira classe :: /first-class functions/
    - Funções de Ordem Superior :: /(Higher-order Functions)/, Funções como
         argumentos, Funções como valores retornados;
    - Composição de funções :: Combinação de funções;
    - Aplicação Parcial de Funções :: /Currying/
    - Primitivas Básicas de PF :: /map/, /filter/, /fold/, /reduce/, /scan/, e
         /zip/;

**** Manipulação de coleções
     Uma coleção é um agrupamento de um número variável de itens, que (1)
     compartilham algum significado ao problema a se resolver e (2) precisam ser
     manipulados juntos de forma controlada.

     O único tipo de coleção no JavaScript é o arranjo (/array/), que pode ser
     construído através do objeto[fn:prototypes] global ~Array~, ou da notação
     de arranjos literais com colchetes:

     #+BEGIN_SRC js
     var collection1 = new Array()
     var collection2 = []
     #+END_SRC

     Uma tarefa muito comum na programação é a iteração[fn:iteration] de
     coleções. Um mecanismo muito utilizado para tal é o comando ~for~. Em
     \ref{code:forLoopTraverse} é demonstrado o uso do comando ~for~ para
     percorrer os itens da coleção ~people~ e mostrar cada um no console de
     depuração.

     #+caption: Percorrendo uma coleção com o laço ~for~
     #+label: code:forLoopTraverse
     #+BEGIN_SRC js
     var people = ["Alan Turing", "Alonzo Church", "Kurt Gödel"]
     var count

     for (count = 0; count < people.length; count++) {
       console.log(people[count])
     }
     #+END_SRC

     Em \ref{code:forLoopDoubleNumbers} é demonstrada a tarefa de dobrar os
     valores de uma coleção de números, que utiliza a instrução ~for~ para
     percorrer os itens. Cada valor é multiplicado por 2, e o resultado é
     adicionado a outra coleção.

     #+label: code:forLoopDoubleNumbers
     #+caption: Dobrando os valores de uma coleção com ~for~
     #+BEGIN_SRC js
     var numbers = [1, 2, 3, 4]      // coleção original
     var doubled = []                // coleção de resultados
     var i                           // contador

     for (i = 0; i < numbers.length; i++) {
       var dobro = numbers[i] * 2    // dobra o valor
       doubled.push(dobro)           // adiciona aos resultados
     }
     // doubled == [2, 4, 6, 8]
     #+END_SRC

     Outro construto usado para iterar coleções é o ~forEach~, implementado no
     JavaScript como método do objeto ~Array~. Dada uma função, o ~forEach~ a
     aplica a cada item da coleção. A tarefa de dobrar os valores de uma coleção
     é demonstrada em \ref{code:forEachDoubleNumbers}, onde é passada uma função
     /lambda/[fn:lambda] ao método ~forEach~, que é aplica a cada item da
     coleção.

     #+label: code:forEachDoubleNumbers
     #+caption: Dobrando os valores de uma coleção com ~forEach()~
     #+BEGIN_SRC js
     var numbers = [1, 2, 3, 4]
     var doubled = []

     numbers.forEach(function (number) {
       var dobro = number * 2
       doubled.push(dobro)
     })
     // doubled == [2, 4, 6, 8]
     #+END_SRC

     Na linha 4 do trecho de código \ref{code:forEachDoubleNumbers}, a expressão
     ~numbers.forEach~ pode ser lida como: “Dada a coleção ~numbers~, aplique a
     seguinte função para cada um de seus itens”. O ~forEach~ permite
     especificar /o que/ acontece para cada item na coleção, porém esconde
     /como/ a coleção é percorrida. Nota-se que não há um contador explícito,
     como no caso do comando ~for~ em \ref{code:forLoopDoubleNumbers}.

     A chave para entender PFR é ter um bom fundamento sobre o uso de
     programação funcional para manipular coleções (/sequências/ nos
     *Objetivos*). Programação funcional oferece ferramentas para abstrair
     operações comuns de coleções em blocos reutilizáveis e de fácil
     composição[fn:composition].

     A maioria das operações de manipulação de coleções podem ser realizadas com
     cinco funções básicas — ~map~, ~filter~, ~concatAll~, ~reduce~, e ~zip~ —
     consideradas ferramentas fundamentais no paradigma de programação
     funcional.

***** Projeção de coleções com ~map()~
      A aplicação de uma função a um valor, afim de criar um novo valor, define
      uma /projeção/. Uma função de projeção pode ser definida como $f(x)=x*2$,
      a aplicação dessa projeção ao valor $2$, resulta no valor $4$:
      $f(2)=2*2=4$.

      Para projetar uma coleção em outra, deve-se aplicar uma
      função a cada item da coleção e coletar os resultados em uma nova coleção.
      Projeções são muito utilizadas para transformar os valores de uma lista —
      e.g. multiplica-los por 2 para obter o dobro, como demonstrado em
      \ref{code:forEachDoubleNumbers} com o ~forEach()~.

      Além do ~forEach~, outro mecanismo para projeção de coleções é a função
      ~map~, muito comum na programação funcional. No JavaScript ela também é
      implementada como um método do objeto ~Array~. Dada uma função, o método
      ~map()~ a aplica a cada item da coleção e coleta os resultados em uma nova
      coleção, que é retornada no final da operação. Em
      \ref{code:mapDoubleNumbers} o método ~map()~ é usado para demonstrar a
      projeção de uma coleção de números inteiros — a mesma projeção feita em
      \ref{code:forEachDoubleNumbers} com o método ~forEach~.

      #+label: code:mapDoubleNumbers
      #+caption: Dobrando os valores de uma coleção com ~map()~
      #+BEGIN_SRC js
      var numbers = [1, 2, 3, 4]
      var doubled = []

      doubled = numbers.map(function (numbers) {
        return number * 2
      })
      // doubled == [2, 4, 6, 8]
      #+END_SRC

      Nota-se que a função ~map~ permite especificar /que/ projeção aplicar a
      uma coleção, mas oculta /como/ a operação acontece.

****** Notas                                                       :noexport:
       [[http://www.pontov.com.br/site/arquitetura/54-matematica-e-fisica/238-matrizes-e-transformacoes-parte-1][Transformação de matrizes]].
******* How -> What
        Trocar sentenças que explicam /como/ as operações de transformação
        funcionam por sentenças que definem /o que/ elas são. E talvez
        esclarecer os objetivos da aplicação delas a coleções.

***** Filtrando coleções com ~filter()~
      Assim como projetar coleções, filtrar coleções é uma operação muito comum.
      Para filtrar uma coleção, aplica-se um teste para cada item da coleção, e
      os que passam no teste são coletados em uma nova coleção.

      #+label: code:filterEvenOdd
      #+BEGIN_SRC js
      var numeros = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

      var pares   = numeros.filter(num => num % 2 == 0) // filtra os números pares
      var impares = numeros.filter(num => num % 2 != 0) // filtra os números ímpares

      // pares   = [0, 2, 4, 6, 8]
      // impares = [1, 3, 5, 7, 9]
      #+END_SRC

      Da mesma forma que ~map()~, ~filter()~ permite expressar /que/ valores são
      desejados, sem exigir que se especifique /como/ coletá-los.

***** Nivelamento de coleções com ~concatAll()~
      Concatena várias listas em uma única lista, ou seja, transforma uma
      coleção de coleções em uma única coleção.

      #+BEGIN_SRC js
      var lista = [[1, 3, 5, 7], [2, 4]]

      var listaNivelada = lista.concatAll()

      // listaNivelada = [1, 3, 5, 7, 2, 4]
      #+END_SRC

      Vale observar que a função ~contatAll()~ espera que cada item da coleção
      também seja uma coleção.

****** Anotações                                                   :noexport:
       Other names for ~concatAll~:
       - flattenDeep ([[https://lodash.com/docs/4.17.4#flattenDeep][lodash]]);
       - concat ([[http://package.elm-lang.org/packages/elm-lang/core/5.1.1/List#concat][elm]]);

***** Redução de coleções com ~reduce()~
      Reduz uma lista a um valor

      #+caption: Somar uma lista de números com ~reduce()~
      #+BEGIN_SRC js
      function somar (total, valor) {
        return total + valor
      }

      let nums = [1, 2, 3]

      let resultado = nums.reduce(somar, 0)

      /* 0: segundo argumento de reduce
         1: primeiro item da coleção
         somar(0, 1) -> 1
                  somar(1, 2) -> 3
                           somar(3, 3) -> 6️
      */
      #+END_SRC


      #+caption: Procurar o maior número com ~reduce()~
      #+BEGIN_SRC js
      let numeros = [2, 3, 1, 4, 5]

      let qualEhMaior = (maior, atual) => {
        if (maior > atual) {
          return maior
        } else {
          return atual
        }
      }

      let resultado = numeros.reduce(qualEhMaior)

      // resultado == 5
      #+END_SRC

      #+caption: Aplicações de ~qualEhMaior()~ com pela função ~reduce()~
      #+BEGIN_SRC js
      /*
       qualEhMaior(2, 3) -> 3
                qualEhMaior(3, 1) -> 3
                         qualEhMaior(3, 4) -> 4
                                  qualEhMaior(4, 5) -> 5
      */
      #+END_SRC

***** Agrupando os itens de uma coleção com ~zip()~
      Combina os itens de várias listas, um a um.

      #+caption: ~zip()~
      #+BEGIN_SRC js
      var listas = [[1, 4],
                    [2, 5],
                    [3, 6]]

      var l2 = zip(listas)

      // l2 = [[1, 2, 3],
      //       [4, 5, 6]]
      #+END_SRC

      #+caption: ~zip()~
      #+BEGIN_SRC js
      var listas = [['we', 'are'],
                    [1111, 22222],
                    [true, false]]

      var ls = zip(listas)

      // ls = [[ 'we',  1111,  true],
      //       ['are', 22222, false]]
      #+END_SRC


**** Notes                                                         :noexport:
     "Functional Programming (enabled by lambdas with closure)".

     Contextualização Histórica.

     Renascença da Programação Funcional.

     - [[  % https://www.youtube.com/watch?v=qJgff2spvzM&t=666s][Composition - Nik Graf at ReactEurope2017]]
     - [[https://www.youtube.com/watch?v=yYze0gCBtvY&t=45s][Functional && Reactive - Preethi at ReactEurope2017]]
       - imutability enables /referencial transparency/

***** Leitura Recomendada                                          :noexport:
****** Melo, 2004, pg. 141
       “Os aspectos teóricos da programação funcional, principalmente relativos
       ao $\lambda$-cálculo, são apresentados de forma resumida em [10]. Uma
       representação bastante mais extensa pode ser encontrada em [9]. Em [28]
       encontramos outra exposição dos fundamentos de processos computacionais
       com base no $\lambda$-cálculo.”

       “Em [44] encontramos uma apresentação mais ‘leve’ da programação
       funcional, que exige menos maturidade matemática do leitor.”

       - [9] H.P. BARENDREGT. /The Lambda Calculus, its Syntax e Semantics/.
         North-Holle, 1984.
       - [10] H.P. BARENDREGT. Functional programming e lambda calculus.
         Elsevier, 1990.
       - [28] J.C. MITCHEL. Foundations of Programming Languages, MIT
         Press, 1996.
       - [44] D.A. WATT. Programming Language Concepts e Paradigms. 1990.

*** Programação Reativa

*** Programação Funcional Reativa

    Em relação a evolução das metodologias de desenvolvimento, Melo (2003)
    comenta:

    #+BEGIN_EXPORT latex
    \begin{citacao}
      Novos elementos são permanentemente incorporados às linguagens visando suprir
      as características emergentes dessas metodologias de desenvolvimento, e/ou
      novas formas de implementação de elementos das linguagens surgem junto com as
      mudanças nas metodologias. (pg. 10)
    \end{citacao}
   #+END_EXPORT

    #+ATTR_LATEX: :options [font={\normalfont\itshape},style=nextline]
    - As 10 Primitivas Básicas :: /map/, /merge/, /hold/, /snapshot/, /filter/,
         /lift/, /never/, /constant/, /sample/, /switch/;
    - Combinação de Primitivas ::
    - Arcabouços /(Frameworks)/ :: /Rx.JS/, /Bacon.js/.

**** Notes                                                         :noexport:
     % "FRP permits the modeling of systems that must respond to input over time in a
     % simple and declarative manner." ~ Amsden (2011), Survey on FRP

     % "A program in an FRP language generally corresponds quite closely to a
     % mathematical model of the system being implemented." ~ Amsden (2011), Survey
     % on FRP
     %   - Programação Reativa
     %     - “[…] is programming with asynchronous data streams” – André Staltz
     %   - merge, replay, retry, skip, start, startWith

     % Ferramentas
     %   Bibliotecas & Frameworks
     %   Bacon.js
     %   Cycle.js → Model-View-Intent
     %   Elm → Model-Update-View
     %   Rx
     %   Meteor

** Interfaces Gráficas do Usuário
   Interfaces gráficas do usuário (GUIs) mediam a maioria de nossas interações
   com computadores, seja através de páginas web, aplicativos de celular, ou
   aplicações desktop cite:czaplicki2012. Um dos principais desafios no
   desenvolvimento de interfaces gráficas é atender requisitos de usabilidade
   cite:myers1994. Observar como interagimos com computadores pode motivar
   maneiras aprimoradas de interação. /Observar/ e /projetar/ novas formas de
   interação são estudadas pela área de /Interação Humano-computador (IHC)/.

   Embora sejam aspectos muito importantes para o desenvolvimento de aplicações,
   eles não concernem a este trabalho. Estamos interessados no desenvolvimento
   de interfaces gráficas do ponto de vista da /programação/. A programação de
   GUIs representa um domínio particularmente difícil. Além dos desafios comuns
   de programação, analizar e transformar dados, elas precisam responder a ações
   do usuário, como clicks do mouse, pressionamento de teclas, e gestos
   multitoque. Devido a isso, interfaces gráficas são designadas /reativas/, ou
   seja, reagem a eventos desencadeados pela interação com o usuário.

   Um sistema reativo efetua computações em resposta a ocorrência de eventos,
   que por sua vez pode desencadear novos eventos. Alguns exemplos são (1)
   interfaces gráficas, que reagem a ações do usuário, (2) sistemas embarcados,
   que reagem a sinais de hardware, e (3) programas de monitoração e controle,
   que reagem a mudanças no ambiente externo cite:salvaneschi2015.
   # De fato, as partes reativas de um programa são acionadas, de forma
   # assíncrona, pela ocorrência de eventos.

   # Nosso objetivo é estudar conceitos de programação aplicados na resolução de
   # problemas de característica assíncrona, inerentes de sistemas reativos como
   # as interfaces gráficas.

   Interfaces gráficas podem ser divididas em dois grupos: /nativas/ e /web/. As
   nativas são encontradas em aplicações específicas de alguma plataforma, e.g.
   /mobile/ (Android, iOS) ou /desktop/ (Ubuntu, RedHat, Windows, Mac).
   Interfaces web são encontradas em aplicações acessadas por navegadores, em
   algum endereço específico na internet, como por exemplo o Gmail, Facebook, e
   Google Docs.

   # justificar o foco em aplicações web
*** Programação de Interfaces Gráficas
    Conforme é notado por \citeonline{blackheath2016}, a maioria das aplicações
    que interagem com o ambiente externo são arquitetadas em torno de dois
    modelos de programaçao, ou uma mistura dos dois:

    - /Threads/ :: modelam transições de estado como um fluxo de controle.
                   Adequadas para operações de I/O ou qualquer situação onde as
                   iiiii         transições de estado se enquadram em uma sequência
                   claramente definida.
    - Eventos :: são mensagens discretas[fn:discrete] e assíncronas que são propagadas pela
                 aplicação. Formam um modelo adequado para sequências menos
                 óbvias, principalmente onde as interações entre componentes
                 são mais complexas. Algumas aplicações incluem /GUIs/ e video
                 games.

    Alguns problemas de computação são melhor resolvidos com o modelo baseado
    em /threads/. No entanto \citeonline{blackheath2016} afirmam que a
    abordagem com eventos geralmente é a melhor escolha.

    - utilizam toolkits

*** Aplicações Web
    - JavaScript
    - DOM /(Document Object Model)/
    - Programação com /Callbacks/
